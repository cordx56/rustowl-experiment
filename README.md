# 実験用Rust学習資料

## 基礎

### 関数

関数は`fn`キーワードを用いて作成する。

```rust
fn main() {
    println!("Hello, world!");
}
```

`main`関数が実行ファイルのエントリーポイントである。

### 変数

変数宣言は`let`文を用いて行う。

```rust
fn main() {
    let a = 1;
}
```

`let`文で宣言される変数はそのままでは不変であり、書き換えができない。
書き換えを可能にするには、`let`の後に`mut`をつけ、可変であると宣言する。

```rust
fn main() {
    let mut a = 1;
    a = a + 1;
}
```

### 出力

文字列や変数の出力には`println!`マクロを用いる。

```rust
fn main() {
    let a = 1 + 1;
    println!("1 + 1 = {a:?}");
}
```

### 参照

C言語などと同じように、`&`を式の前につけることで、その式の値への参照を作成できる。

```rust
fn main() {
    let a = 1;
    let b = &a;
    println!("{b:?}");
}
```

`&`のみをつけた参照は不変となり、参照先の書き換えができない。
参照先の書き換えができるようにするには、`&mut`を用いる。

参照先のあたいを読んだり書き換えたりする場合には、参照の前に`*`をつける。

### 制御構文

条件分岐では`if`式を用いる。

```rust
fn main() {
    if "hello" != "world" {
        println!("true");   // 表示される
    } else {
        println!("false");  // 表示されない
    }
}
```

ループは`while`式や`for`式を用いることができる。

```rust
fn main() {
    for i in 0..3 {
        println!("{i:?}"); // 0から2まで表示
    }

    let mut i = 0;
    while true {
        println!("{i:?}"); // 0から2まで表示
        i += 1;
        if i == 2 {
            break;
        }
    }
}
```

### 文字列

文字列には`&str`型と`String`型がある。
本実験では`&str`は用いず、`String`型のみ考える。

```rust
fn main() {
    let mut hello = String::from("Hello");
    hello.push_str(", world");
    println!("{hello:?}");
}
```

## 所有権

Rustでは各変数が値の所有権を持っており、所有権を移したり、貸し借りをすることで値の代入、参照や変更できる。
所有権を他の変数に移すと元の変数は参照できなくなる。
所有権を他の変数に貸す際には、値の変更ができない不変借用と、値の変更ができる可変借用がある。
変数の値が他の場所で参照している最中に書き換えられないようにするため、可変借用は他の借用と共存できない。

#### 所有権の移動

所有権が移動する型（おおよそプリミティブ型以外）の所有権は、変数への代入や関数の引数への値渡しで移動する。

```rust
fn consume(v: Vec<i32>) {
    println!("consume {v:?}"); // 可変長配列を消費する関数
}
fn main() {
    let owner = vec![1, 2, 3]; // 可変長配列を初期化
    println!("{owner:?}");     // 配列を文字として出力
    consume(owner);            // 所有権が関数`consume`の引数`v`に移る
    println!("{owner:?}");     // ownerは所有権を持っていないのでエラー
}
```

#### 借用（参照）

式の前に`&`を付与することによって、その式の評価結果の値を不変借用することができる。
なお、借用は参照と同義である。
不変借用はメソッド呼び出しの際に暗黙的に作られることもある。

```rust
fn main() {
    let owner = vec![1, 2, 3]; // 可変長配列を初期化
    let first = &owner[0];     // 可変長配列の1番目を不変借用
    println!("{first:?}");     // 配列の1番目を文字として出力
}
```

可変借用を行う場合は、`&mut`を使う。
可変借用はメソッド呼び出しの際に暗黙的に作られることもある。

```rust
fn main() {
    let owner = vec![1, 2, 3]; // 可変長配列を初期化
    let first = &mut owner[0]; // 可変長配列の1番目を可変借用
    *first = 4;                // 1番目の可変借用の中身に4を代入する
    println!("{first:?}");     // 配列の1番目を文字として出力
}
```

可変借用と他の借用が同時に存在することはできない。

```rust
fn main() {
    let owner = vec![1, 2, 3];  // 可変長配列を初期化
    let first = &owner[0];      // 可変長配列の1番目を不変借用
    let second = &mut owner[1]; // 可変長配列の2番目を可変借用
    *second = 4;                // この後でownerの要素に対する不変借用が
                                // 使われているため、可変借用は使えない
    println!("{first:?}");      // ownerの要素に対する不変借用は
                                // ここで使われている
}
```

## ライフタイム

Rustにおいて、変数はライフタイムを持つ。
変数および変数への参照は、その変数のライフタイムの範囲内においてのみ利用できる。

```rust
fn main() {
    if true {
        let owner = vec![1, 2, 3]; // 変数`owner`はif式のスコープ内で
                                   // 宣言されている
        let first = &owner[0];     // ここで変数`owner`の要素への
                                   // 参照`first`を作る
        println!("{first:?}");
    }
    println!("{first:?}");         // 変数`owner`への参照`first`が
                                   // 変数`owner`のライフタイム外で
                                   // 使われているため、エラー
}
```

## おわり

説明した制約を守らない場合、コンパイルエラーとなる。
